# Accelerating CreateIfLabs.AutoMapper (Without Runtime IL Emission)

The goal is to analyze potential strategies to optimize `CreateIfLabs.AutoMapper` without relying on `System.Reflection.Emit` (IL code generation) at runtime. The original AutoMapper achieves its phenomenal speed by compiling dynamic mappings into pure IL logic. However, there are modern .NET techniques that can rival or even surpass traditional IL emission.

## Summary of the Bottleneck

Currently, `CreateIfLabs.AutoMapper` uses:
```csharp
var srcVal = sourcePropCopy.GetValue(src);
destPropCopy.SetValue(dest, converted);
```
Standard Reflection (`PropertyInfo.GetValue` / `SetValue`) is notoriously slow because:
1. It involves boxing/unboxing value types.
2. It requires security/visibility checks on every invocation.
3. It cannot be easily inlined by the JIT compiler.

To speed this up, we need to bypass standard reflection.

---

## Strategy 1: Compiled Expression Trees (Semi-IL)

While the requirement states "not using IL optimization", Expression Trees (`System.Linq.Expressions`) are a high-level abstraction natively built into .NET that compile down to delegates. Technically, .NET compiles these to IL under the hood, but as a developer, you don't write IL directly.

**How it works:**
Instead of storing `PropertyInfo` in the `MappingPlan`, we dynamically build an expression tree that represents `dest.Prop = src.Prop`.

```csharp
// Concept
var srcParam = Expression.Parameter(typeof(object), "src");
var destParam = Expression.Parameter(typeof(object), "dest");

var castSrc = Expression.Convert(srcParam, sourceType);
var castDest = Expression.Convert(destParam, destType);

var getProp = Expression.Property(castSrc, sourceProp);
var setProp = Expression.Assign(Expression.Property(castDest, destProp), getProp);

var lambda = Expression.Lambda<Action<object, object>>(setProp, srcParam, destParam);
Action<object, object> fastAssign = lambda.Compile();
```

**Pros:** 
- Extremely fast (nearly as fast as raw IL once compiled).
- Much easier to write and maintain than raw `Reflection.Emit`.
**Cons:** 
- Compilation is slow (the first map will take longer).
- Technically still uses IL generation under the hood (via `LambdaExpression.Compile`).
- Not friendly for AOT (Ahead-of-Time) compilation (e.g., Unity IL2CPP or NativeAOT), which is a major factor in modern .NET.

---

## Strategy 2: Pre-compiled Source Generators (The Modern Approach) ðŸ”¥

If the goal is to *beat* AutoMapper, **C# Source Generators** are the best approach. Instead of figuring out mappings at runtime, a Source Generator analyzes your code during the design/compile phase and generates pure, strongly-typed C# code to map the objects.

**How it works:**
When the user writes `mapper.Map<SourceModel, DestModel>(src)`, the compiler intercepts this and actually writes a hidden file in the background:

```csharp
// Auto-generated by Source Generator at compile time
public static class MapperImpl 
{
    public static DestModel Map(SourceModel src) 
    {
        if (src == null) return null;
        return new DestModel {
            Id = src.Id,
            Name = src.Name,
            Price = src.Price,
            // ... direct property access, zero reflection!
        };
    }
}
```

**Pros:**
- **Zero Runtime Overhead**: It's as fast as writing the mapping code manually.
- **Beat AutoMapper**: Source generators consistently beat AutoMapper in benchmarks (e.g., libraries like Mapperly do exactly this).
- **AOT / Trimming Safe**: Because there is no reflection or dynamic code generation, it works perfectly in modern cloud-native/AOT environments.
- **Compile-Time Errors**: If a property changes name and breaks the map, the build fails immediately rather than throwing a runtime error.
**Cons:**
- Requires significant rewriting of the library to be a Roslyn Analyzer/Generator rather than a runtime engine.
- Configuration (like `ForMember`) has to be done via attributes or very specific builder patterns rather than dynamic runtime initialization.

---

## Strategy 3: Fast Reflection Helpers (`Delegate.CreateDelegate`)

If we must stay within a runtime engine *without* expression trees or IL emit, the classic approach is extracting open delegates from `PropertyInfo.GetMethod` and `SetMethod`.

**How it works:**
Instead of calling `PropertyInfo.GetValue(obj)`, you create a strongly typed delegate.

```csharp
// For getting a property
var getMethod = propertyInfo.GetGetMethod();
var getter = (Func<TSource, TProperty>)Delegate.CreateDelegate(typeof(Func<TSource, TProperty>), null, getMethod);

// For setting a property
var setMethod = propertyInfo.GetSetMethod();
var setter = (Action<TDest, TProperty>)Delegate.CreateDelegate(typeof(Action<TDest, TProperty>), null, setMethod);
```

To store this generically in a list (since `TSource`/`TProperty` change per property), you usually wrap them in an interface or cast to generic helper classes.

**Pros:**
- Massive speedup over standard reflection.
- No IL generation or Expression Trees involved.
- Works in AOT environments (mostly).
**Cons:**
- Storing these generically requires interface boxing or dynamic dispatch, which eats up some of the performance gains.
- Hard to handle type conversions cleanly compared to Expression Trees or IL.

---

## Strategy 4: Reflection Wrapper Libraries (e.g., FastMember)

This is a variant of Strategy 1/3. Using a library like Marc Gravell's `FastMember` provides `TypeAccessor` which gives extremely fast, cached property access.

```csharp
var accessor = TypeAccessor.Create(typeof(SourceModel));
var value = accessor[src, "Name"];
```
**Pros:** Easy to implement, abstracts away the complexity.
**Cons:** Brings an external dependency; under the hood, `FastMember` uses IL emission (Reflection.Emit), which violates the premise.

---

## Conclusion & Recommendation

Is it possible to beat the original AutoMapper's IL implementation entirely? 
**Yes, by using C# Source Generators (Strategy 2).** 

If a user writes the mappings by hand, it will always be faster than an IL-generated runtime mapper. A Source Generator literally writes that manual mapping code for you during the build step. In the .NET ecosystem today (e.g., .NET 8/9+), the push is heavily towards Source Generators specifically to eliminate startup penalties and enable AOT compilationâ€”something AutoMapper struggles with due to its heavy reliance on Expression Trees/IL.

**If shifting to Source Generators is too drastic** for `CreateIfLabs.AutoMapper`, the best immediate improvement to the current engine without using `Reflection.Emit` is **Strategy 3 (Delegate.CreateDelegate)**. It will eliminate the severe penalty of `PropertyInfo.SetValue`, but it likely won't *beat* AutoMapper's IL speedâ€”it will just get much closer.

---

## The "Fast Reflection + Caching" Approach

Your intuition is spot on! Because property definitions do not change at runtime, we **must** cache the reflection accessors to get any performance benefit. In fact, `CreateIfLabs.AutoMapper` already has a perfect caching mechanism in place: the `MappingPlan` inside the `ConcurrentDictionary`.

Currently, the cache stores a `List<Action<object, object>>`. The problem is that inside those actions, it is calling standard reflection:
```csharp
// Current Slow Cache implementation:
plan.PropertyActions.Add((src, dest) => {
    var srcVal = sourcePropCopy.GetValue(src); // <--- Major bottleneck
    destPropCopy.SetValue(dest, converted);    // <--- Major bottleneck
});
```

If we combine **Fast Reflection via `Delegate.CreateDelegate`** with the existing `MappingPlan` cache, we generate strongly-typed delegates once per type pair, and cache the invocation:

```csharp
// Proposed Super Fast Reflection + Caching implementation:
// 1. Create the fast strongly-typed delegates once during building the plan
var getMethod = sourcePropCopy.GetGetMethod();
var getterDelegate = Delegate.CreateDelegate(typeof(Func<TSource, TProp>), null, getMethod);

var setMethod = destPropCopy.GetSetMethod();
var setterDelegate = Delegate.CreateDelegate(typeof(Action<TDest, TProp>), null, setMethod);

// 2. Cache the invocation using the delegates instead of PropertyInfo
plan.PropertyActions.Add((src, dest) => {
    // 3. Cast to specific types and execute delegates
    // No boxing/unboxing for standard properties!
    var val = ((Func<TSource, TProp>)getterDelegate)((TSource)src);
    ((Action<TDest, TProp>)setterDelegate)((TDest)dest, val);
});
```

### Is this a "Super Fast" Approach?
**Yes!** By combining Delegate creation with the existing cache, you:
1. Pay the heavy reflection parsing cost only exactly **once** (during `_planCache.GetOrAdd`).
2. Completely eliminate security checks and type-boxing inside the property getters and setters.

### Can it beat AutoMapper's IL?
It will be **incredibly fast** (drastically cutting down the 1218 ms to potentially 200-300 ms), but it will likely still be narrowly beaten by original AutoMapper v16 (140 ms). 

Why? Because AutoMapper isn't just generating delegates for each property; it takes the entire object mapping and writes one massive, continuously inlined IL method (`dest.Id = src.Id; dest.Name = src.Name;`). Fast Reflection still has the overhead of executing a looped `Action<object, object>` list and casting objects underneath. 

However, this Fast Reflection + Caching approach gives you **90% of the speed** with just **10% of the complexity** of writing custom IL/Expression Tree generation. It is the absolute best upgrade you could make to the current library while keeping the codebase simple.
